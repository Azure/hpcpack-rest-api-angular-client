/**
 * HPC Pack REST API 2016
 * This is the API spec for Microsoft HPC Pack 2016 Update 3.
 *
 * OpenAPI spec version: 2016-11-01.5.3
 * Contact: hpcpack@microsoft.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { MetricData } from '../model/metricData';
import { MetricDefinition } from '../model/metricDefinition';
import { NodeAvailability } from '../model/nodeAvailability';
import { NodeMetric } from '../model/nodeMetric';
import { RestObject } from '../model/restObject';
import { RestProperty } from '../model/restProperty';
import { UserRole } from '../model/userRole';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable({
  providedIn: 'root'
})
export class DefaultService {

    protected basePath = 'https://localhost/hpc';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Add Task
     * Add a task to a job.
     * @param jobId Job Id
     * @param x_ms_as_user The name of user whom you want to make request as. You must be an HPC Pack administrator or HPC Pack Job administrator to make it work.
     * @param properties Properties of task to add.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addTask(jobId: number, x_ms_as_user?: string, properties?: Array<RestProperty>, observe?: 'body', reportProgress?: boolean): Observable<number>;
    public addTask(jobId: number, x_ms_as_user?: string, properties?: Array<RestProperty>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<number>>;
    public addTask(jobId: number, x_ms_as_user?: string, properties?: Array<RestProperty>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<number>>;
    public addTask(jobId: number, x_ms_as_user?: string, properties?: Array<RestProperty>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (jobId === null || jobId === undefined) {
            throw new Error('Required parameter jobId was null or undefined when calling addTask.');
        }



        let headers = this.defaultHeaders;
        if (x_ms_as_user !== undefined && x_ms_as_user !== null) {
            headers = headers.set('x-ms-as-user', String(x_ms_as_user));
        }

        // authentication (basic) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<number>(`${this.basePath}/jobs/${encodeURIComponent(String(jobId))}/tasks`,
            properties,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Cancel Job
     * Cancel the specified job.
     * @param jobId Job Id
     * @param x_ms_as_user The name of user whom you want to make request as. You must be an HPC Pack administrator or HPC Pack Job administrator to make it work.
     * @param forced Specifies whether to stop the job immediately without using the grace period for canceling the tasks in the job and without running the node release task, if the job contains one. True indicates that the job should stop immediately without using the grace period for canceling the tasks in the job and without running the node release task. False indicates that the job should not stop immediately and should use the grace period for canceling the tasks in the job and run the node release task.
     * @param message A message for the operation.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public cancelJob(jobId: number, x_ms_as_user?: string, forced?: boolean, message?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public cancelJob(jobId: number, x_ms_as_user?: string, forced?: boolean, message?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public cancelJob(jobId: number, x_ms_as_user?: string, forced?: boolean, message?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public cancelJob(jobId: number, x_ms_as_user?: string, forced?: boolean, message?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (jobId === null || jobId === undefined) {
            throw new Error('Required parameter jobId was null or undefined when calling cancelJob.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (forced !== undefined && forced !== null) {
            queryParameters = queryParameters.set('forced', <any>forced);
        }

        let headers = this.defaultHeaders;
        if (x_ms_as_user !== undefined && x_ms_as_user !== null) {
            headers = headers.set('x-ms-as-user', String(x_ms_as_user));
        }

        // authentication (basic) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/jobs/${encodeURIComponent(String(jobId))}/cancel`,
            message,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Cancel Subtask
     * Cancel the specified subtask.
     * @param jobId Job Id
     * @param taskId Task Id
     * @param subtaskId Subtask Id
     * @param x_ms_as_user The name of user whom you want to make request as. You must be an HPC Pack administrator or HPC Pack Job administrator to make it work.
     * @param forced Specifies whether to stop the subtask immediately without using the grace period for canceling a task. True indicates that the subtask should stop immediately without using the grace period for canceling a task. False indicates that the subtask should use the grace period for canceling.
     * @param message A message for the operation.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public cancelSubtask(jobId: number, taskId: number, subtaskId: number, x_ms_as_user?: string, forced?: boolean, message?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public cancelSubtask(jobId: number, taskId: number, subtaskId: number, x_ms_as_user?: string, forced?: boolean, message?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public cancelSubtask(jobId: number, taskId: number, subtaskId: number, x_ms_as_user?: string, forced?: boolean, message?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public cancelSubtask(jobId: number, taskId: number, subtaskId: number, x_ms_as_user?: string, forced?: boolean, message?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (jobId === null || jobId === undefined) {
            throw new Error('Required parameter jobId was null or undefined when calling cancelSubtask.');
        }

        if (taskId === null || taskId === undefined) {
            throw new Error('Required parameter taskId was null or undefined when calling cancelSubtask.');
        }

        if (subtaskId === null || subtaskId === undefined) {
            throw new Error('Required parameter subtaskId was null or undefined when calling cancelSubtask.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (forced !== undefined && forced !== null) {
            queryParameters = queryParameters.set('forced', <any>forced);
        }

        let headers = this.defaultHeaders;
        if (x_ms_as_user !== undefined && x_ms_as_user !== null) {
            headers = headers.set('x-ms-as-user', String(x_ms_as_user));
        }

        // authentication (basic) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/jobs/${encodeURIComponent(String(jobId))}/tasks/${encodeURIComponent(String(taskId))}/subtasks/${encodeURIComponent(String(subtaskId))}/cancel`,
            message,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Cancel Task
     * Cancel the specified task.
     * @param jobId Job Id
     * @param taskId Task Id
     * @param x_ms_as_user The name of user whom you want to make request as. You must be an HPC Pack administrator or HPC Pack Job administrator to make it work.
     * @param forced Specifies whether to stop the task immediately without using the grace period for canceling a task. True indicates that the task should stop immediately without using the grace period for canceling a task. False indicates that the task should use the grace period for canceling a task.
     * @param message A message for the operation.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public cancelTask(jobId: number, taskId: number, x_ms_as_user?: string, forced?: boolean, message?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public cancelTask(jobId: number, taskId: number, x_ms_as_user?: string, forced?: boolean, message?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public cancelTask(jobId: number, taskId: number, x_ms_as_user?: string, forced?: boolean, message?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public cancelTask(jobId: number, taskId: number, x_ms_as_user?: string, forced?: boolean, message?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (jobId === null || jobId === undefined) {
            throw new Error('Required parameter jobId was null or undefined when calling cancelTask.');
        }

        if (taskId === null || taskId === undefined) {
            throw new Error('Required parameter taskId was null or undefined when calling cancelTask.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (forced !== undefined && forced !== null) {
            queryParameters = queryParameters.set('forced', <any>forced);
        }

        let headers = this.defaultHeaders;
        if (x_ms_as_user !== undefined && x_ms_as_user !== null) {
            headers = headers.set('x-ms-as-user', String(x_ms_as_user));
        }

        // authentication (basic) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/jobs/${encodeURIComponent(String(jobId))}/tasks/${encodeURIComponent(String(taskId))}/cancel`,
            message,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create Job
     * Creates a new job on the HPC cluster.
     * @param x_ms_as_user The name of user whom you want to make request as. You must be an HPC Pack administrator or HPC Pack Job administrator to make it work.
     * @param properties Properties of job to create
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createJob(x_ms_as_user?: string, properties?: Array<RestProperty>, observe?: 'body', reportProgress?: boolean): Observable<number>;
    public createJob(x_ms_as_user?: string, properties?: Array<RestProperty>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<number>>;
    public createJob(x_ms_as_user?: string, properties?: Array<RestProperty>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<number>>;
    public createJob(x_ms_as_user?: string, properties?: Array<RestProperty>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let headers = this.defaultHeaders;
        if (x_ms_as_user !== undefined && x_ms_as_user !== null) {
            headers = headers.set('x-ms-as-user', String(x_ms_as_user));
        }

        // authentication (basic) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<number>(`${this.basePath}/jobs`,
            properties,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create Job From XML
     * Create a new job on the HPC cluster by using the information in the specified job XML string.
     * @param x_ms_as_user The name of user whom you want to make request as. You must be an HPC Pack administrator or HPC Pack Job administrator to make it work.
     * @param xml A job described in XML. For an example:  &#x60;&#x60;&#x60;xml &lt;Job&gt;   &lt;Tasks&gt;     &lt;Task CommandLine&#x3D;\&quot;hostname\&quot; MinCores&#x3D;\&quot;1\&quot; MaxCores&#x3D;\&quot;1\&quot; /&gt;   &lt;/Tasks&gt; &lt;/Job&gt; &#x60;&#x60;&#x60;  Note that since the server accepts input in JSON, the XML has to be encoded in a JSON string.  See [Job Schema](https://docs.microsoft.com/en-us/previous-versions/windows/desktop/cc907034%28v%3dvs.85%29) for more details on the XML content. 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createJobFromXml(x_ms_as_user?: string, xml?: string, observe?: 'body', reportProgress?: boolean): Observable<number>;
    public createJobFromXml(x_ms_as_user?: string, xml?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<number>>;
    public createJobFromXml(x_ms_as_user?: string, xml?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<number>>;
    public createJobFromXml(x_ms_as_user?: string, xml?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let headers = this.defaultHeaders;
        if (x_ms_as_user !== undefined && x_ms_as_user !== null) {
            headers = headers.set('x-ms-as-user', String(x_ms_as_user));
        }

        // authentication (basic) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<number>(`${this.basePath}/jobs/jobFile`,
            xml,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Finish Job
     * Finish the specified job. It&#39;s silimar to canceling a job, but sets the job state to \&quot;Finished\&quot; rather than \&quot;Canceled\&quot;.
     * @param jobId Job Id
     * @param x_ms_as_user The name of user whom you want to make request as. You must be an HPC Pack administrator or HPC Pack Job administrator to make it work.
     * @param message A message for the operation.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public finishJob(jobId: number, x_ms_as_user?: string, message?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public finishJob(jobId: number, x_ms_as_user?: string, message?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public finishJob(jobId: number, x_ms_as_user?: string, message?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public finishJob(jobId: number, x_ms_as_user?: string, message?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (jobId === null || jobId === undefined) {
            throw new Error('Required parameter jobId was null or undefined when calling finishJob.');
        }



        let headers = this.defaultHeaders;
        if (x_ms_as_user !== undefined && x_ms_as_user !== null) {
            headers = headers.set('x-ms-as-user', String(x_ms_as_user));
        }

        // authentication (basic) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/jobs/${encodeURIComponent(String(jobId))}/finish`,
            message,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Finish Subtask
     * Finish the specified subtask.
     * @param jobId Job Id
     * @param taskId Task Id
     * @param subtaskId Subtask Id
     * @param x_ms_as_user The name of user whom you want to make request as. You must be an HPC Pack administrator or HPC Pack Job administrator to make it work.
     * @param message A message for the operation.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public finishSubtask(jobId: number, taskId: number, subtaskId: number, x_ms_as_user?: string, message?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public finishSubtask(jobId: number, taskId: number, subtaskId: number, x_ms_as_user?: string, message?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public finishSubtask(jobId: number, taskId: number, subtaskId: number, x_ms_as_user?: string, message?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public finishSubtask(jobId: number, taskId: number, subtaskId: number, x_ms_as_user?: string, message?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (jobId === null || jobId === undefined) {
            throw new Error('Required parameter jobId was null or undefined when calling finishSubtask.');
        }

        if (taskId === null || taskId === undefined) {
            throw new Error('Required parameter taskId was null or undefined when calling finishSubtask.');
        }

        if (subtaskId === null || subtaskId === undefined) {
            throw new Error('Required parameter subtaskId was null or undefined when calling finishSubtask.');
        }



        let headers = this.defaultHeaders;
        if (x_ms_as_user !== undefined && x_ms_as_user !== null) {
            headers = headers.set('x-ms-as-user', String(x_ms_as_user));
        }

        // authentication (basic) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/jobs/${encodeURIComponent(String(jobId))}/tasks/${encodeURIComponent(String(taskId))}/subtasks/${encodeURIComponent(String(subtaskId))}/finish`,
            message,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Finish Task
     * Finish the specified task. It&#39;s silimar to canceling a task, but sets the task state to \&quot;Finished\&quot; rather than \&quot;Canceled\&quot;.
     * @param jobId Job Id
     * @param taskId Task Id
     * @param x_ms_as_user The name of user whom you want to make request as. You must be an HPC Pack administrator or HPC Pack Job administrator to make it work.
     * @param message A message for the operation.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public finishTask(jobId: number, taskId: number, x_ms_as_user?: string, message?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public finishTask(jobId: number, taskId: number, x_ms_as_user?: string, message?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public finishTask(jobId: number, taskId: number, x_ms_as_user?: string, message?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public finishTask(jobId: number, taskId: number, x_ms_as_user?: string, message?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (jobId === null || jobId === undefined) {
            throw new Error('Required parameter jobId was null or undefined when calling finishTask.');
        }

        if (taskId === null || taskId === undefined) {
            throw new Error('Required parameter taskId was null or undefined when calling finishTask.');
        }



        let headers = this.defaultHeaders;
        if (x_ms_as_user !== undefined && x_ms_as_user !== null) {
            headers = headers.set('x-ms-as-user', String(x_ms_as_user));
        }

        // authentication (basic) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/jobs/${encodeURIComponent(String(jobId))}/tasks/${encodeURIComponent(String(taskId))}/finish`,
            message,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Active Head Node Name
     * Get the name of the active head node of the HPC Pack cluster.
     * @param x_ms_as_user The name of user whom you want to make request as. You must be an HPC Pack administrator or HPC Pack Job administrator to make it work.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getClusterActiveHeadNode(x_ms_as_user?: string, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public getClusterActiveHeadNode(x_ms_as_user?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public getClusterActiveHeadNode(x_ms_as_user?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public getClusterActiveHeadNode(x_ms_as_user?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;
        if (x_ms_as_user !== undefined && x_ms_as_user !== null) {
            headers = headers.set('x-ms-as-user', String(x_ms_as_user));
        }

        // authentication (basic) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<string>(`${this.basePath}/cluster/activeHeadNode`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get DateTime Format
     * Get DateTime format for the DateTime objects returned in the API
     * @param x_ms_as_user The name of user whom you want to make request as. You must be an HPC Pack administrator or HPC Pack Job administrator to make it work.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getClusterDateTimeFormat(x_ms_as_user?: string, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public getClusterDateTimeFormat(x_ms_as_user?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public getClusterDateTimeFormat(x_ms_as_user?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public getClusterDateTimeFormat(x_ms_as_user?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;
        if (x_ms_as_user !== undefined && x_ms_as_user !== null) {
            headers = headers.set('x-ms-as-user', String(x_ms_as_user));
        }

        // authentication (basic) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<string>(`${this.basePath}/cluster/info/dateTimeFormat`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Cluster Job Metrics
     * Get cluster job metrics for the last 7 days.
     * @param x_ms_as_user The name of user whom you want to make request as. You must be an HPC Pack administrator or HPC Pack Job administrator to make it work.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getClusterJobMetrics(x_ms_as_user?: string, observe?: 'body', reportProgress?: boolean): Observable<MetricData>;
    public getClusterJobMetrics(x_ms_as_user?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<MetricData>>;
    public getClusterJobMetrics(x_ms_as_user?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<MetricData>>;
    public getClusterJobMetrics(x_ms_as_user?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;
        if (x_ms_as_user !== undefined && x_ms_as_user !== null) {
            headers = headers.set('x-ms-as-user', String(x_ms_as_user));
        }

        // authentication (basic) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<MetricData>(`${this.basePath}/cluster/metrics/jobs`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get cluster metric definitions
     * Get cluster metric definitions. You can then get the history of a metric.
     * @param x_ms_as_user The name of user whom you want to make request as. You must be an HPC Pack administrator or HPC Pack Job administrator to make it work.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getClusterMetricDefintions(x_ms_as_user?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<MetricDefinition>>;
    public getClusterMetricDefintions(x_ms_as_user?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<MetricDefinition>>>;
    public getClusterMetricDefintions(x_ms_as_user?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<MetricDefinition>>>;
    public getClusterMetricDefintions(x_ms_as_user?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;
        if (x_ms_as_user !== undefined && x_ms_as_user !== null) {
            headers = headers.set('x-ms-as-user', String(x_ms_as_user));
        }

        // authentication (basic) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<MetricDefinition>>(`${this.basePath}/cluster/metrics/definitions`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get cluster metric history
     * Get cluster metric history
     * @param name Metric name
     * @param fromTime The start time in UTC
     * @param toTime The end time in UTC
     * @param x_ms_as_user The name of user whom you want to make request as. You must be an HPC Pack administrator or HPC Pack Job administrator to make it work.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getClusterMetricHistory(name: string, fromTime: Date, toTime: Date, x_ms_as_user?: string, observe?: 'body', reportProgress?: boolean): Observable<MetricData>;
    public getClusterMetricHistory(name: string, fromTime: Date, toTime: Date, x_ms_as_user?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<MetricData>>;
    public getClusterMetricHistory(name: string, fromTime: Date, toTime: Date, x_ms_as_user?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<MetricData>>;
    public getClusterMetricHistory(name: string, fromTime: Date, toTime: Date, x_ms_as_user?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getClusterMetricHistory.');
        }

        if (fromTime === null || fromTime === undefined) {
            throw new Error('Required parameter fromTime was null or undefined when calling getClusterMetricHistory.');
        }

        if (toTime === null || toTime === undefined) {
            throw new Error('Required parameter toTime was null or undefined when calling getClusterMetricHistory.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (fromTime !== undefined && fromTime !== null) {
            queryParameters = queryParameters.set('fromTime', <any>fromTime.toISOString());
        }
        if (toTime !== undefined && toTime !== null) {
            queryParameters = queryParameters.set('toTime', <any>toTime.toISOString());
        }

        let headers = this.defaultHeaders;
        if (x_ms_as_user !== undefined && x_ms_as_user !== null) {
            headers = headers.set('x-ms-as-user', String(x_ms_as_user));
        }

        // authentication (basic) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<MetricData>(`${this.basePath}/cluster/metrics/history/${encodeURIComponent(String(name))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Cluster Node Availability
     * Get cluster node availability.
     * @param x_ms_as_user The name of user whom you want to make request as. You must be an HPC Pack administrator or HPC Pack Job administrator to make it work.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getClusterNodeAvailability(x_ms_as_user?: string, observe?: 'body', reportProgress?: boolean): Observable<NodeAvailability>;
    public getClusterNodeAvailability(x_ms_as_user?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<NodeAvailability>>;
    public getClusterNodeAvailability(x_ms_as_user?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<NodeAvailability>>;
    public getClusterNodeAvailability(x_ms_as_user?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;
        if (x_ms_as_user !== undefined && x_ms_as_user !== null) {
            headers = headers.set('x-ms-as-user', String(x_ms_as_user));
        }

        // authentication (basic) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<NodeAvailability>(`${this.basePath}/cluster/nodeAvailability`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get HPC Pack Version
     * Get the version of Microsoft HPC Pack installed on the HPC cluster that hosts the web service.
     * @param x_ms_as_user The name of user whom you want to make request as. You must be an HPC Pack administrator or HPC Pack Job administrator to make it work.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getClusterVersion(x_ms_as_user?: string, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public getClusterVersion(x_ms_as_user?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public getClusterVersion(x_ms_as_user?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public getClusterVersion(x_ms_as_user?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;
        if (x_ms_as_user !== undefined && x_ms_as_user !== null) {
            headers = headers.set('x-ms-as-user', String(x_ms_as_user));
        }

        // authentication (basic) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<string>(`${this.basePath}/cluster/version`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Job
     * Get information about the specified job.
     * @param jobId Job Id
     * @param x_ms_as_user The name of user whom you want to make request as. You must be an HPC Pack administrator or HPC Pack Job administrator to make it work.
     * @param properties A comma-separated list of the names for the properties of the job for which you want to get values. If you do not specify this parameter, the response contains values for all of the properties of the job. See [ISchedulerJob](https://docs.microsoft.com/en-us/previous-versions/windows/desktop/cc897474%28v%3dvs.85%29) for available properties.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getJob(jobId: number, x_ms_as_user?: string, properties?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<RestProperty>>;
    public getJob(jobId: number, x_ms_as_user?: string, properties?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<RestProperty>>>;
    public getJob(jobId: number, x_ms_as_user?: string, properties?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<RestProperty>>>;
    public getJob(jobId: number, x_ms_as_user?: string, properties?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (jobId === null || jobId === undefined) {
            throw new Error('Required parameter jobId was null or undefined when calling getJob.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (properties !== undefined && properties !== null) {
            queryParameters = queryParameters.set('properties', <any>properties);
        }

        let headers = this.defaultHeaders;
        if (x_ms_as_user !== undefined && x_ms_as_user !== null) {
            headers = headers.set('x-ms-as-user', String(x_ms_as_user));
        }

        // authentication (basic) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<RestProperty>>(`${this.basePath}/jobs/${encodeURIComponent(String(jobId))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Job Custom Properties
     * Get the values of the specified custom properties for the job, or the values of all of the properties if none are specified.
     * @param jobId Job Id
     * @param x_ms_as_user The name of user whom you want to make request as. You must be an HPC Pack administrator or HPC Pack Job administrator to make it work.
     * @param names A comma-separated list of the names for the custom properties of the job for which you want to get values. If you do not specify the Names parameter, the response contains values for all of the custom properties for the job.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getJobCustomProperties(jobId: number, x_ms_as_user?: string, names?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<RestProperty>>;
    public getJobCustomProperties(jobId: number, x_ms_as_user?: string, names?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<RestProperty>>>;
    public getJobCustomProperties(jobId: number, x_ms_as_user?: string, names?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<RestProperty>>>;
    public getJobCustomProperties(jobId: number, x_ms_as_user?: string, names?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (jobId === null || jobId === undefined) {
            throw new Error('Required parameter jobId was null or undefined when calling getJobCustomProperties.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (names !== undefined && names !== null) {
            queryParameters = queryParameters.set('names', <any>names);
        }

        let headers = this.defaultHeaders;
        if (x_ms_as_user !== undefined && x_ms_as_user !== null) {
            headers = headers.set('x-ms-as-user', String(x_ms_as_user));
        }

        // authentication (basic) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<RestProperty>>(`${this.basePath}/jobs/${encodeURIComponent(String(jobId))}/customProperties`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Job Environment Variables
     * Get the values of the specified environment variables for the job, or the values of all of the environment variables if none are specified.
     * @param jobId Job Id
     * @param x_ms_as_user The name of user whom you want to make request as. You must be an HPC Pack administrator or HPC Pack Job administrator to make it work.
     * @param names A comma-separated list of the names for the environment variables in the job for which you want to get values. If you do not specify the Names parameter, the response contains values for all of the environment variables for the job. If an environment variable with a specified name does not exist for the job, the response contains an empty string for the value of that environment variable.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getJobEnvironmentVariables(jobId: number, x_ms_as_user?: string, names?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<RestProperty>>;
    public getJobEnvironmentVariables(jobId: number, x_ms_as_user?: string, names?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<RestProperty>>>;
    public getJobEnvironmentVariables(jobId: number, x_ms_as_user?: string, names?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<RestProperty>>>;
    public getJobEnvironmentVariables(jobId: number, x_ms_as_user?: string, names?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (jobId === null || jobId === undefined) {
            throw new Error('Required parameter jobId was null or undefined when calling getJobEnvironmentVariables.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (names !== undefined && names !== null) {
            queryParameters = queryParameters.set('names', <any>names);
        }

        let headers = this.defaultHeaders;
        if (x_ms_as_user !== undefined && x_ms_as_user !== null) {
            headers = headers.set('x-ms-as-user', String(x_ms_as_user));
        }

        // authentication (basic) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<RestProperty>>(`${this.basePath}/jobs/${encodeURIComponent(String(jobId))}/envVariables`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Job Templates
     * Get a list of the names of the job templates that are available on the HPC cluster.
     * @param x_ms_as_user The name of user whom you want to make request as. You must be an HPC Pack administrator or HPC Pack Job administrator to make it work.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getJobTemplates(x_ms_as_user?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<string>>;
    public getJobTemplates(x_ms_as_user?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<string>>>;
    public getJobTemplates(x_ms_as_user?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<string>>>;
    public getJobTemplates(x_ms_as_user?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;
        if (x_ms_as_user !== undefined && x_ms_as_user !== null) {
            headers = headers.set('x-ms-as-user', String(x_ms_as_user));
        }

        // authentication (basic) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<string>>(`${this.basePath}/jobs/templates`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Job List
     * Gets all/filtered jobs for the HPC cluster.
     * @param x_ms_as_user The name of user whom you want to make request as. You must be an HPC Pack administrator or HPC Pack Job administrator to make it work.
     * @param properties A comma-separated list of the names for the properties of the jobs for which you want to get values. See [ISchedulerJob](https://docs.microsoft.com/en-us/previous-versions/windows/desktop/cc897474%28v%3dvs.85%29) for available properties.
     * @param owner The user who created, submitted, or queued the job.
     * @param filter Filter jobs by specified filters. A filter is in the form of \&quot;&lt;name&gt;%20eq%20&lt;value&gt;\&quot;, and multiple filters can be ANDed like \&quot;&lt;filter1&gt;%20and%20&lt;filter2&gt;\&quot;. Available filter names are _JobState_, _NodeGroup_ and _ChangeTimeFrom_. 
     * @param sortJobsBy A job property by which jobs will be sorted. If this parameter is not specified or a property with a specified name does not exist for a job, the result will be sorted by job Id.
     * @param asc Specifies the sort order.
     * @param startRow Specifies the start number of rows to read. The number of the first row is 0. When this parameter presents, pagination is activated and _queryId_ is ignored. And the total number of rows will be returned in the response header _x-ms-row-count_, while no _x-ms-continuation-queryId_ will be returned.
     * @param rowsPerRead Specifies how many rows of data to retrieve each time.
     * @param queryId The value of the _x-ms-continuation-queryId_ header from the previouse response of this operation, used for reading the next page of data.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getJobs(x_ms_as_user?: string, properties?: string, owner?: string, filter?: string, sortJobsBy?: string, asc?: boolean, startRow?: number, rowsPerRead?: number, queryId?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<RestObject>>;
    public getJobs(x_ms_as_user?: string, properties?: string, owner?: string, filter?: string, sortJobsBy?: string, asc?: boolean, startRow?: number, rowsPerRead?: number, queryId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<RestObject>>>;
    public getJobs(x_ms_as_user?: string, properties?: string, owner?: string, filter?: string, sortJobsBy?: string, asc?: boolean, startRow?: number, rowsPerRead?: number, queryId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<RestObject>>>;
    public getJobs(x_ms_as_user?: string, properties?: string, owner?: string, filter?: string, sortJobsBy?: string, asc?: boolean, startRow?: number, rowsPerRead?: number, queryId?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {










        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (properties !== undefined && properties !== null) {
            queryParameters = queryParameters.set('properties', <any>properties);
        }
        if (owner !== undefined && owner !== null) {
            queryParameters = queryParameters.set('owner', <any>owner);
        }
        if (filter !== undefined && filter !== null) {
            queryParameters = queryParameters.set('$filter', <any>filter);
        }
        if (sortJobsBy !== undefined && sortJobsBy !== null) {
            queryParameters = queryParameters.set('sortJobsBy', <any>sortJobsBy);
        }
        if (asc !== undefined && asc !== null) {
            queryParameters = queryParameters.set('asc', <any>asc);
        }
        if (startRow !== undefined && startRow !== null) {
            queryParameters = queryParameters.set('startRow', <any>startRow);
        }
        if (rowsPerRead !== undefined && rowsPerRead !== null) {
            queryParameters = queryParameters.set('rowsPerRead', <any>rowsPerRead);
        }
        if (queryId !== undefined && queryId !== null) {
            queryParameters = queryParameters.set('queryId', <any>queryId);
        }

        let headers = this.defaultHeaders;
        if (x_ms_as_user !== undefined && x_ms_as_user !== null) {
            headers = headers.set('x-ms-as-user', String(x_ms_as_user));
        }

        // authentication (basic) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<RestObject>>(`${this.basePath}/jobs`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Node by Name
     * Get the values of all of the properties for the specified node.
     * @param name Node name.
     * @param x_ms_as_user The name of user whom you want to make request as. You must be an HPC Pack administrator or HPC Pack Job administrator to make it work.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getNodeByName(name: string, x_ms_as_user?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<RestProperty>>;
    public getNodeByName(name: string, x_ms_as_user?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<RestProperty>>>;
    public getNodeByName(name: string, x_ms_as_user?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<RestProperty>>>;
    public getNodeByName(name: string, x_ms_as_user?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getNodeByName.');
        }


        let headers = this.defaultHeaders;
        if (x_ms_as_user !== undefined && x_ms_as_user !== null) {
            headers = headers.set('x-ms-as-user', String(x_ms_as_user));
        }

        // authentication (basic) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<RestProperty>>(`${this.basePath}/nodes/${encodeURIComponent(String(name))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Node Group Members
     * Get the list of the nodes that belong to the specified node group.
     * @param name Node group name.
     * @param x_ms_as_user The name of user whom you want to make request as. You must be an HPC Pack administrator or HPC Pack Job administrator to make it work.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getNodeGroupMembers(name: string, x_ms_as_user?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<string>>;
    public getNodeGroupMembers(name: string, x_ms_as_user?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<string>>>;
    public getNodeGroupMembers(name: string, x_ms_as_user?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<string>>>;
    public getNodeGroupMembers(name: string, x_ms_as_user?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getNodeGroupMembers.');
        }


        let headers = this.defaultHeaders;
        if (x_ms_as_user !== undefined && x_ms_as_user !== null) {
            headers = headers.set('x-ms-as-user', String(x_ms_as_user));
        }

        // authentication (basic) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<string>>(`${this.basePath}/nodes/groups/${encodeURIComponent(String(name))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Node Group List
     * Get the names and descriptions for all of the node groups for the HPC cluster.
     * @param x_ms_as_user The name of user whom you want to make request as. You must be an HPC Pack administrator or HPC Pack Job administrator to make it work.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getNodeGroups(x_ms_as_user?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<RestObject>>;
    public getNodeGroups(x_ms_as_user?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<RestObject>>>;
    public getNodeGroups(x_ms_as_user?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<RestObject>>>;
    public getNodeGroups(x_ms_as_user?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;
        if (x_ms_as_user !== undefined && x_ms_as_user !== null) {
            headers = headers.set('x-ms-as-user', String(x_ms_as_user));
        }

        // authentication (basic) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<RestObject>>(`${this.basePath}/nodes/groups`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Node Metrics
     * Get metrics of nodes
     * @param metricNames A comma separated names of metrics, available names are HPCCpuUsage, HPCMemoryPaging, HPCDiskThroughput, HPCNetwork and HPCCoresInUse
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getNodeMetrics(metricNames: string, observe?: 'body', reportProgress?: boolean): Observable<Array<NodeMetric>>;
    public getNodeMetrics(metricNames: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<NodeMetric>>>;
    public getNodeMetrics(metricNames: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<NodeMetric>>>;
    public getNodeMetrics(metricNames: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (metricNames === null || metricNames === undefined) {
            throw new Error('Required parameter metricNames was null or undefined when calling getNodeMetrics.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (metricNames !== undefined && metricNames !== null) {
            queryParameters = queryParameters.set('metricNames', <any>metricNames);
        }

        let headers = this.defaultHeaders;

        // authentication (basic) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<NodeMetric>>(`${this.basePath}/nodes/metrics`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Node List
     * Get the values of the specified properties for all of the nodes in an HPC cluster.
     * @param x_ms_as_user The name of user whom you want to make request as. You must be an HPC Pack administrator or HPC Pack Job administrator to make it work.
     * @param nodeNames A comma-separated list of names for which the node info will be retrieved. When this parameter is specified, all other parameters except the \&quot;x-ms-as-user\&quot; header are ignored. All properties of a node will be retrieved. When an invalid name is present, or when any exception happens, no node info for that name will be returned. So the the result length may be less than the one of the input name array. 
     * @param properties A comma-separated list of the names for the properties of the nodes for which you want to get values. If you do not specify the Properties parameter, the response contains values for all of the available properties of the nodes. See [ISchedulerNode](https://docs.microsoft.com/en-us/previous-versions/windows/desktop/cc897552(v&#x3D;vs.85)) for available properties.
     * @param filter Filter result by specified filters. A filter is in the form of \&quot;&lt;name&gt;%20eq%20&lt;value&gt;\&quot;. Now the only available filter is _NodeState_. 
     * @param sortNodesBy A node property by which nodes will be sorted. If this parameter is not specified or a property with a specified name does not exist for a node, the result will be sorted by node Id.
     * @param asc Specifies the sort order.
     * @param startRow Specifies the start number of rows to read. The number of the first row is 0. When this parameter presents, pagination is activated and _queryId_ is ignored. And the total number of rows will be returned in the response header _x-ms-row-count_, while no _x-ms-continuation-queryId_ will be returned.
     * @param rowsPerRead Specifies how many rows of data to retrieve each time.
     * @param queryId The value of the _x-ms-continuation-queryId_ header from the previouse response of this operation, used for reading the next page of data.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getNodes(x_ms_as_user?: string, nodeNames?: string, properties?: string, filter?: string, sortNodesBy?: string, asc?: boolean, startRow?: number, rowsPerRead?: number, queryId?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<RestObject>>;
    public getNodes(x_ms_as_user?: string, nodeNames?: string, properties?: string, filter?: string, sortNodesBy?: string, asc?: boolean, startRow?: number, rowsPerRead?: number, queryId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<RestObject>>>;
    public getNodes(x_ms_as_user?: string, nodeNames?: string, properties?: string, filter?: string, sortNodesBy?: string, asc?: boolean, startRow?: number, rowsPerRead?: number, queryId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<RestObject>>>;
    public getNodes(x_ms_as_user?: string, nodeNames?: string, properties?: string, filter?: string, sortNodesBy?: string, asc?: boolean, startRow?: number, rowsPerRead?: number, queryId?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {










        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (nodeNames !== undefined && nodeNames !== null) {
            queryParameters = queryParameters.set('nodeNames', <any>nodeNames);
        }
        if (properties !== undefined && properties !== null) {
            queryParameters = queryParameters.set('properties', <any>properties);
        }
        if (filter !== undefined && filter !== null) {
            queryParameters = queryParameters.set('$filter', <any>filter);
        }
        if (sortNodesBy !== undefined && sortNodesBy !== null) {
            queryParameters = queryParameters.set('sortNodesBy', <any>sortNodesBy);
        }
        if (asc !== undefined && asc !== null) {
            queryParameters = queryParameters.set('asc', <any>asc);
        }
        if (startRow !== undefined && startRow !== null) {
            queryParameters = queryParameters.set('startRow', <any>startRow);
        }
        if (rowsPerRead !== undefined && rowsPerRead !== null) {
            queryParameters = queryParameters.set('rowsPerRead', <any>rowsPerRead);
        }
        if (queryId !== undefined && queryId !== null) {
            queryParameters = queryParameters.set('queryId', <any>queryId);
        }

        let headers = this.defaultHeaders;
        if (x_ms_as_user !== undefined && x_ms_as_user !== null) {
            headers = headers.set('x-ms-as-user', String(x_ms_as_user));
        }

        // authentication (basic) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<RestObject>>(`${this.basePath}/nodes`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Subtask
     * Get the values of the specified properties for the specified subtask, or the values of all of the properties if no properties are specified. Only Parameteric Sweep job have subtasks.
     * @param jobId Job Id
     * @param taskId Task Id
     * @param subtaskId Subtask Id
     * @param x_ms_as_user The name of user whom you want to make request as. You must be an HPC Pack administrator or HPC Pack Job administrator to make it work.
     * @param properties A comma-separated list of the names for the properties of the subtask for which you want to get values. If you do not specify this parameter, the response contains values for all of the properties of the subtask. See [ISchedulerTask](https://docs.microsoft.com/en-us/previous-versions/windows/desktop/cc897577(v&#x3D;vs.85)) for avaialbe properties.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getSubtask(jobId: number, taskId: number, subtaskId: number, x_ms_as_user?: string, properties?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<RestProperty>>;
    public getSubtask(jobId: number, taskId: number, subtaskId: number, x_ms_as_user?: string, properties?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<RestProperty>>>;
    public getSubtask(jobId: number, taskId: number, subtaskId: number, x_ms_as_user?: string, properties?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<RestProperty>>>;
    public getSubtask(jobId: number, taskId: number, subtaskId: number, x_ms_as_user?: string, properties?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (jobId === null || jobId === undefined) {
            throw new Error('Required parameter jobId was null or undefined when calling getSubtask.');
        }

        if (taskId === null || taskId === undefined) {
            throw new Error('Required parameter taskId was null or undefined when calling getSubtask.');
        }

        if (subtaskId === null || subtaskId === undefined) {
            throw new Error('Required parameter subtaskId was null or undefined when calling getSubtask.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (properties !== undefined && properties !== null) {
            queryParameters = queryParameters.set('properties', <any>properties);
        }

        let headers = this.defaultHeaders;
        if (x_ms_as_user !== undefined && x_ms_as_user !== null) {
            headers = headers.set('x-ms-as-user', String(x_ms_as_user));
        }

        // authentication (basic) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<RestProperty>>(`${this.basePath}/jobs/${encodeURIComponent(String(jobId))}/tasks/${encodeURIComponent(String(taskId))}/subtasks/${encodeURIComponent(String(subtaskId))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Task
     * Get the values of the specified properties for the specified task, or the values of all of the properties if no properties are specified.
     * @param jobId Job Id
     * @param taskId Task Id
     * @param x_ms_as_user The name of user whom you want to make request as. You must be an HPC Pack administrator or HPC Pack Job administrator to make it work.
     * @param properties A comma-separated list of the names for the properties of the task for which you want to get values. If you do not specify this parameter, the response contains values for all of the properties of the task. See [ISchedulerTask](https://docs.microsoft.com/en-us/previous-versions/windows/desktop/cc897577(v&#x3D;vs.85)) for avaialbe properties.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTask(jobId: number, taskId: number, x_ms_as_user?: string, properties?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<RestProperty>>;
    public getTask(jobId: number, taskId: number, x_ms_as_user?: string, properties?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<RestProperty>>>;
    public getTask(jobId: number, taskId: number, x_ms_as_user?: string, properties?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<RestProperty>>>;
    public getTask(jobId: number, taskId: number, x_ms_as_user?: string, properties?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (jobId === null || jobId === undefined) {
            throw new Error('Required parameter jobId was null or undefined when calling getTask.');
        }

        if (taskId === null || taskId === undefined) {
            throw new Error('Required parameter taskId was null or undefined when calling getTask.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (properties !== undefined && properties !== null) {
            queryParameters = queryParameters.set('properties', <any>properties);
        }

        let headers = this.defaultHeaders;
        if (x_ms_as_user !== undefined && x_ms_as_user !== null) {
            headers = headers.set('x-ms-as-user', String(x_ms_as_user));
        }

        // authentication (basic) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<RestProperty>>(`${this.basePath}/jobs/${encodeURIComponent(String(jobId))}/tasks/${encodeURIComponent(String(taskId))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Task Custom Properties
     * Get the values of the specified custom properties for the task, or the values of all of the properties if none are specified.
     * @param jobId Job Id
     * @param taskId Task Id
     * @param x_ms_as_user The name of user whom you want to make request as. You must be an HPC Pack administrator or HPC Pack Job administrator to make it work.
     * @param names A comma-separated list of the names for the custom properties of the task for which you want to get values. If you do not specify the Names parameter, the response contains values for all of the custom properties for the task.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTaskCustomProperties(jobId: number, taskId: number, x_ms_as_user?: string, names?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<RestProperty>>;
    public getTaskCustomProperties(jobId: number, taskId: number, x_ms_as_user?: string, names?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<RestProperty>>>;
    public getTaskCustomProperties(jobId: number, taskId: number, x_ms_as_user?: string, names?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<RestProperty>>>;
    public getTaskCustomProperties(jobId: number, taskId: number, x_ms_as_user?: string, names?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (jobId === null || jobId === undefined) {
            throw new Error('Required parameter jobId was null or undefined when calling getTaskCustomProperties.');
        }

        if (taskId === null || taskId === undefined) {
            throw new Error('Required parameter taskId was null or undefined when calling getTaskCustomProperties.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (names !== undefined && names !== null) {
            queryParameters = queryParameters.set('names', <any>names);
        }

        let headers = this.defaultHeaders;
        if (x_ms_as_user !== undefined && x_ms_as_user !== null) {
            headers = headers.set('x-ms-as-user', String(x_ms_as_user));
        }

        // authentication (basic) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<RestProperty>>(`${this.basePath}/jobs/${encodeURIComponent(String(jobId))}/tasks/${encodeURIComponent(String(taskId))}/customProperties`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Task Environment Variables
     * Get the values of the specified environment variables for the task, or the values of all of the environment variables if none are specified.
     * @param jobId Job Id
     * @param taskId Task Id
     * @param x_ms_as_user The name of user whom you want to make request as. You must be an HPC Pack administrator or HPC Pack Job administrator to make it work.
     * @param names A comma-separated list of the names for the environment variables in the task for which you want to get values. If you do not specify the Names parameter, the response contains values for all of the environment variables for the task. If an environment variable with a specified name does not exist for the task, the response contains an empty string for the value of that environment variable.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTaskEnvironmentVariables(jobId: number, taskId: number, x_ms_as_user?: string, names?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<RestProperty>>;
    public getTaskEnvironmentVariables(jobId: number, taskId: number, x_ms_as_user?: string, names?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<RestProperty>>>;
    public getTaskEnvironmentVariables(jobId: number, taskId: number, x_ms_as_user?: string, names?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<RestProperty>>>;
    public getTaskEnvironmentVariables(jobId: number, taskId: number, x_ms_as_user?: string, names?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (jobId === null || jobId === undefined) {
            throw new Error('Required parameter jobId was null or undefined when calling getTaskEnvironmentVariables.');
        }

        if (taskId === null || taskId === undefined) {
            throw new Error('Required parameter taskId was null or undefined when calling getTaskEnvironmentVariables.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (names !== undefined && names !== null) {
            queryParameters = queryParameters.set('names', <any>names);
        }

        let headers = this.defaultHeaders;
        if (x_ms_as_user !== undefined && x_ms_as_user !== null) {
            headers = headers.set('x-ms-as-user', String(x_ms_as_user));
        }

        // authentication (basic) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<RestProperty>>(`${this.basePath}/jobs/${encodeURIComponent(String(jobId))}/tasks/${encodeURIComponent(String(taskId))}/envVariables`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Task List
     * Get the values of the properties for all of the tasks in the specified job.
     * @param jobId Job Id
     * @param x_ms_as_user The name of user whom you want to make request as. You must be an HPC Pack administrator or HPC Pack Job administrator to make it work.
     * @param properties A comma-separated list of the names for the properties of the tasks for which you want to get values. See [ISchedulerTask](https://docs.microsoft.com/en-us/previous-versions/windows/desktop/cc897577(v&#x3D;vs.85)) for avaialbe properties.
     * @param expandParametric Specifies whether to get properties only for the master task for a parametric sweep task, or for all of the subtasks instead. True indicates that you want to get properties for all of the subtasks. False indicates that you want to get properties only for the master task.
     * @param filter Filter tasks by specified filters. A filter is in the form of \&quot;&lt;name&gt;%20eq%20&lt;value&gt;\&quot;, and multiple filters can be ANDed like \&quot;&lt;filter1&gt;%20and%20&lt;filter2&gt;\&quot;. Available filter names are _TaskState_, _ChangeTimeFrom_, _TaskStates_, _TaskIds_ and _TaskInstanceIds_. 
     * @param sortTasksBy A task property by which tasks will be sorted. If this parameter is not specified or a property with a specified name does not exist for a task, the result will be sorted by task Id.
     * @param asc Specifies the sort order.
     * @param startRow Specifies the start number of rows to read. The number of the first row is 0. When this parameter presents, pagination is activated and _queryId_ is ignored. And the total number of rows will be returned in the response header _x-ms-row-count_, while no _x-ms-continuation-queryId_ will be returned.
     * @param rowsPerRead Specifies how many rows of data to retrieve each time.
     * @param queryId The value of the _x-ms-continuation-queryId_ header from the previouse response of this operation, used for reading the next page of data.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTasks(jobId: number, x_ms_as_user?: string, properties?: string, expandParametric?: boolean, filter?: string, sortTasksBy?: string, asc?: boolean, startRow?: number, rowsPerRead?: number, queryId?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<RestObject>>;
    public getTasks(jobId: number, x_ms_as_user?: string, properties?: string, expandParametric?: boolean, filter?: string, sortTasksBy?: string, asc?: boolean, startRow?: number, rowsPerRead?: number, queryId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<RestObject>>>;
    public getTasks(jobId: number, x_ms_as_user?: string, properties?: string, expandParametric?: boolean, filter?: string, sortTasksBy?: string, asc?: boolean, startRow?: number, rowsPerRead?: number, queryId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<RestObject>>>;
    public getTasks(jobId: number, x_ms_as_user?: string, properties?: string, expandParametric?: boolean, filter?: string, sortTasksBy?: string, asc?: boolean, startRow?: number, rowsPerRead?: number, queryId?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (jobId === null || jobId === undefined) {
            throw new Error('Required parameter jobId was null or undefined when calling getTasks.');
        }










        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (properties !== undefined && properties !== null) {
            queryParameters = queryParameters.set('properties', <any>properties);
        }
        if (expandParametric !== undefined && expandParametric !== null) {
            queryParameters = queryParameters.set('expandParametric', <any>expandParametric);
        }
        if (filter !== undefined && filter !== null) {
            queryParameters = queryParameters.set('$filter', <any>filter);
        }
        if (sortTasksBy !== undefined && sortTasksBy !== null) {
            queryParameters = queryParameters.set('sortTasksBy', <any>sortTasksBy);
        }
        if (asc !== undefined && asc !== null) {
            queryParameters = queryParameters.set('asc', <any>asc);
        }
        if (startRow !== undefined && startRow !== null) {
            queryParameters = queryParameters.set('startRow', <any>startRow);
        }
        if (rowsPerRead !== undefined && rowsPerRead !== null) {
            queryParameters = queryParameters.set('rowsPerRead', <any>rowsPerRead);
        }
        if (queryId !== undefined && queryId !== null) {
            queryParameters = queryParameters.set('queryId', <any>queryId);
        }

        let headers = this.defaultHeaders;
        if (x_ms_as_user !== undefined && x_ms_as_user !== null) {
            headers = headers.set('x-ms-as-user', String(x_ms_as_user));
        }

        // authentication (basic) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<RestObject>>(`${this.basePath}/jobs/${encodeURIComponent(String(jobId))}/tasks`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Cluster User Roles
     * Get the roles of the cluster user who makes the API call.
     * @param x_ms_as_user The name of user whom you want to make request as. You must be an HPC Pack administrator or HPC Pack Job administrator to make it work.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUserRoles(x_ms_as_user?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<UserRole>>;
    public getUserRoles(x_ms_as_user?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<UserRole>>>;
    public getUserRoles(x_ms_as_user?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<UserRole>>>;
    public getUserRoles(x_ms_as_user?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;
        if (x_ms_as_user !== undefined && x_ms_as_user !== null) {
            headers = headers.set('x-ms-as-user', String(x_ms_as_user));
        }

        // authentication (basic) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<UserRole>>(`${this.basePath}/cluster/userRoles`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Perform Operations on Nodes
     * Perform operations, such as take nodes online/offline, on nodes.
     * @param operation The operation to do.
     * @param nodeNames 
     * @param x_ms_as_user The name of user whom you want to make request as. You must be an HPC Pack administrator or HPC Pack Job administrator to make it work.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public operateNodes(operation: 'online' | 'offline', nodeNames: Array<string>, x_ms_as_user?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public operateNodes(operation: 'online' | 'offline', nodeNames: Array<string>, x_ms_as_user?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public operateNodes(operation: 'online' | 'offline', nodeNames: Array<string>, x_ms_as_user?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public operateNodes(operation: 'online' | 'offline', nodeNames: Array<string>, x_ms_as_user?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (operation === null || operation === undefined) {
            throw new Error('Required parameter operation was null or undefined when calling operateNodes.');
        }

        if (nodeNames === null || nodeNames === undefined) {
            throw new Error('Required parameter nodeNames was null or undefined when calling operateNodes.');
        }


        let headers = this.defaultHeaders;
        if (x_ms_as_user !== undefined && x_ms_as_user !== null) {
            headers = headers.set('x-ms-as-user', String(x_ms_as_user));
        }

        // authentication (basic) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/nodes/operations/${encodeURIComponent(String(operation))}`,
            nodeNames,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Requeue Job
     * Resubmit the specified job to the queue.
     * @param jobId Job Id
     * @param x_ms_as_user The name of user whom you want to make request as. You must be an HPC Pack administrator or HPC Pack Job administrator to make it work.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public requeueJob(jobId: number, x_ms_as_user?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public requeueJob(jobId: number, x_ms_as_user?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public requeueJob(jobId: number, x_ms_as_user?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public requeueJob(jobId: number, x_ms_as_user?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (jobId === null || jobId === undefined) {
            throw new Error('Required parameter jobId was null or undefined when calling requeueJob.');
        }


        let headers = this.defaultHeaders;
        if (x_ms_as_user !== undefined && x_ms_as_user !== null) {
            headers = headers.set('x-ms-as-user', String(x_ms_as_user));
        }

        // authentication (basic) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.post<any>(`${this.basePath}/jobs/${encodeURIComponent(String(jobId))}/requeue`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Requeue Subtask
     * Move a failed, canceled, or queued subtask to the configuring state so that the subtask can be queued again when the job is resubmitted.
     * @param jobId Job Id
     * @param taskId Task Id
     * @param subtaskId Subtask Id
     * @param x_ms_as_user The name of user whom you want to make request as. You must be an HPC Pack administrator or HPC Pack Job administrator to make it work.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public requeueSubtask(jobId: number, taskId: number, subtaskId: number, x_ms_as_user?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public requeueSubtask(jobId: number, taskId: number, subtaskId: number, x_ms_as_user?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public requeueSubtask(jobId: number, taskId: number, subtaskId: number, x_ms_as_user?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public requeueSubtask(jobId: number, taskId: number, subtaskId: number, x_ms_as_user?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (jobId === null || jobId === undefined) {
            throw new Error('Required parameter jobId was null or undefined when calling requeueSubtask.');
        }

        if (taskId === null || taskId === undefined) {
            throw new Error('Required parameter taskId was null or undefined when calling requeueSubtask.');
        }

        if (subtaskId === null || subtaskId === undefined) {
            throw new Error('Required parameter subtaskId was null or undefined when calling requeueSubtask.');
        }


        let headers = this.defaultHeaders;
        if (x_ms_as_user !== undefined && x_ms_as_user !== null) {
            headers = headers.set('x-ms-as-user', String(x_ms_as_user));
        }

        // authentication (basic) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.post<any>(`${this.basePath}/jobs/${encodeURIComponent(String(jobId))}/tasks/${encodeURIComponent(String(taskId))}/subtasks/${encodeURIComponent(String(subtaskId))}/requeue`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Requeue Task
     * Move a failed, canceled, or queued task to the configuring state so that the task can be queued again when the job is resubmitted.
     * @param jobId Job Id
     * @param taskId Task Id
     * @param x_ms_as_user The name of user whom you want to make request as. You must be an HPC Pack administrator or HPC Pack Job administrator to make it work.
     * @param message A message for the operation.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public requeueTask(jobId: number, taskId: number, x_ms_as_user?: string, message?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public requeueTask(jobId: number, taskId: number, x_ms_as_user?: string, message?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public requeueTask(jobId: number, taskId: number, x_ms_as_user?: string, message?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public requeueTask(jobId: number, taskId: number, x_ms_as_user?: string, message?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (jobId === null || jobId === undefined) {
            throw new Error('Required parameter jobId was null or undefined when calling requeueTask.');
        }

        if (taskId === null || taskId === undefined) {
            throw new Error('Required parameter taskId was null or undefined when calling requeueTask.');
        }



        let headers = this.defaultHeaders;
        if (x_ms_as_user !== undefined && x_ms_as_user !== null) {
            headers = headers.set('x-ms-as-user', String(x_ms_as_user));
        }

        // authentication (basic) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/jobs/${encodeURIComponent(String(jobId))}/tasks/${encodeURIComponent(String(taskId))}/requeue`,
            message,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Set Job Custom Properties
     * Set the values of custom properties for a job.
     * @param jobId Job Id
     * @param x_ms_as_user The name of user whom you want to make request as. You must be an HPC Pack administrator or HPC Pack Job administrator to make it work.
     * @param properties Custom properties for the job
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setJobCustomProperties(jobId: number, x_ms_as_user?: string, properties?: Array<RestProperty>, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public setJobCustomProperties(jobId: number, x_ms_as_user?: string, properties?: Array<RestProperty>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public setJobCustomProperties(jobId: number, x_ms_as_user?: string, properties?: Array<RestProperty>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public setJobCustomProperties(jobId: number, x_ms_as_user?: string, properties?: Array<RestProperty>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (jobId === null || jobId === undefined) {
            throw new Error('Required parameter jobId was null or undefined when calling setJobCustomProperties.');
        }



        let headers = this.defaultHeaders;
        if (x_ms_as_user !== undefined && x_ms_as_user !== null) {
            headers = headers.set('x-ms-as-user', String(x_ms_as_user));
        }

        // authentication (basic) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/jobs/${encodeURIComponent(String(jobId))}/customProperties`,
            properties,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Set Job Environment Variables
     * Sets the values of environment variables for a job.
     * @param jobId Job Id
     * @param x_ms_as_user The name of user whom you want to make request as. You must be an HPC Pack administrator or HPC Pack Job administrator to make it work.
     * @param properties Environment variables for the job
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setJobEnvironmentVariables(jobId: number, x_ms_as_user?: string, properties?: Array<RestProperty>, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public setJobEnvironmentVariables(jobId: number, x_ms_as_user?: string, properties?: Array<RestProperty>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public setJobEnvironmentVariables(jobId: number, x_ms_as_user?: string, properties?: Array<RestProperty>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public setJobEnvironmentVariables(jobId: number, x_ms_as_user?: string, properties?: Array<RestProperty>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (jobId === null || jobId === undefined) {
            throw new Error('Required parameter jobId was null or undefined when calling setJobEnvironmentVariables.');
        }



        let headers = this.defaultHeaders;
        if (x_ms_as_user !== undefined && x_ms_as_user !== null) {
            headers = headers.set('x-ms-as-user', String(x_ms_as_user));
        }

        // authentication (basic) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/jobs/${encodeURIComponent(String(jobId))}/envVariables`,
            properties,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Set Job Properties
     * Set the values for the properties of the specified job.
     * @param jobId Job Id
     * @param x_ms_as_user The name of user whom you want to make request as. You must be an HPC Pack administrator or HPC Pack Job administrator to make it work.
     * @param properties Properties of job to set
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setJobProperties(jobId: number, x_ms_as_user?: string, properties?: Array<RestProperty>, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public setJobProperties(jobId: number, x_ms_as_user?: string, properties?: Array<RestProperty>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public setJobProperties(jobId: number, x_ms_as_user?: string, properties?: Array<RestProperty>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public setJobProperties(jobId: number, x_ms_as_user?: string, properties?: Array<RestProperty>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (jobId === null || jobId === undefined) {
            throw new Error('Required parameter jobId was null or undefined when calling setJobProperties.');
        }



        let headers = this.defaultHeaders;
        if (x_ms_as_user !== undefined && x_ms_as_user !== null) {
            headers = headers.set('x-ms-as-user', String(x_ms_as_user));
        }

        // authentication (basic) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<any>(`${this.basePath}/jobs/${encodeURIComponent(String(jobId))}`,
            properties,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Set Subtask Properties
     * Set the values of properties for a subtask in a job.
     * @param jobId Job Id
     * @param taskId Task Id
     * @param subtaskId Subtask Id
     * @param x_ms_as_user The name of user whom you want to make request as. You must be an HPC Pack administrator or HPC Pack Job administrator to make it work.
     * @param properties Properties of subtask to set.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setSubtaskProperties(jobId: number, taskId: number, subtaskId: number, x_ms_as_user?: string, properties?: Array<RestProperty>, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public setSubtaskProperties(jobId: number, taskId: number, subtaskId: number, x_ms_as_user?: string, properties?: Array<RestProperty>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public setSubtaskProperties(jobId: number, taskId: number, subtaskId: number, x_ms_as_user?: string, properties?: Array<RestProperty>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public setSubtaskProperties(jobId: number, taskId: number, subtaskId: number, x_ms_as_user?: string, properties?: Array<RestProperty>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (jobId === null || jobId === undefined) {
            throw new Error('Required parameter jobId was null or undefined when calling setSubtaskProperties.');
        }

        if (taskId === null || taskId === undefined) {
            throw new Error('Required parameter taskId was null or undefined when calling setSubtaskProperties.');
        }

        if (subtaskId === null || subtaskId === undefined) {
            throw new Error('Required parameter subtaskId was null or undefined when calling setSubtaskProperties.');
        }



        let headers = this.defaultHeaders;
        if (x_ms_as_user !== undefined && x_ms_as_user !== null) {
            headers = headers.set('x-ms-as-user', String(x_ms_as_user));
        }

        // authentication (basic) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<any>(`${this.basePath}/jobs/${encodeURIComponent(String(jobId))}/tasks/${encodeURIComponent(String(taskId))}/subtasks/${encodeURIComponent(String(subtaskId))}`,
            properties,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Set Task Custom Properties
     * Set the values of custom properties for a task.
     * @param jobId Job Id
     * @param taskId Task Id
     * @param x_ms_as_user The name of user whom you want to make request as. You must be an HPC Pack administrator or HPC Pack Job administrator to make it work.
     * @param properties Custom properties for the task
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setTaskCustomProperties(jobId: number, taskId: number, x_ms_as_user?: string, properties?: Array<RestProperty>, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public setTaskCustomProperties(jobId: number, taskId: number, x_ms_as_user?: string, properties?: Array<RestProperty>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public setTaskCustomProperties(jobId: number, taskId: number, x_ms_as_user?: string, properties?: Array<RestProperty>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public setTaskCustomProperties(jobId: number, taskId: number, x_ms_as_user?: string, properties?: Array<RestProperty>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (jobId === null || jobId === undefined) {
            throw new Error('Required parameter jobId was null or undefined when calling setTaskCustomProperties.');
        }

        if (taskId === null || taskId === undefined) {
            throw new Error('Required parameter taskId was null or undefined when calling setTaskCustomProperties.');
        }



        let headers = this.defaultHeaders;
        if (x_ms_as_user !== undefined && x_ms_as_user !== null) {
            headers = headers.set('x-ms-as-user', String(x_ms_as_user));
        }

        // authentication (basic) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/jobs/${encodeURIComponent(String(jobId))}/tasks/${encodeURIComponent(String(taskId))}/customProperties`,
            properties,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Set Task Environment Variables
     * Set the value of one or more environment variables for a task.
     * @param jobId Job Id
     * @param taskId Task Id
     * @param x_ms_as_user The name of user whom you want to make request as. You must be an HPC Pack administrator or HPC Pack Job administrator to make it work.
     * @param properties Environment variables for the task
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setTaskEnvironmentVariables(jobId: number, taskId: number, x_ms_as_user?: string, properties?: Array<RestProperty>, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public setTaskEnvironmentVariables(jobId: number, taskId: number, x_ms_as_user?: string, properties?: Array<RestProperty>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public setTaskEnvironmentVariables(jobId: number, taskId: number, x_ms_as_user?: string, properties?: Array<RestProperty>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public setTaskEnvironmentVariables(jobId: number, taskId: number, x_ms_as_user?: string, properties?: Array<RestProperty>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (jobId === null || jobId === undefined) {
            throw new Error('Required parameter jobId was null or undefined when calling setTaskEnvironmentVariables.');
        }

        if (taskId === null || taskId === undefined) {
            throw new Error('Required parameter taskId was null or undefined when calling setTaskEnvironmentVariables.');
        }



        let headers = this.defaultHeaders;
        if (x_ms_as_user !== undefined && x_ms_as_user !== null) {
            headers = headers.set('x-ms-as-user', String(x_ms_as_user));
        }

        // authentication (basic) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/jobs/${encodeURIComponent(String(jobId))}/tasks/${encodeURIComponent(String(taskId))}/envVariables`,
            properties,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Set Task Properties
     * Set the values of properties for a task in a job.
     * @param jobId Job Id
     * @param taskId Task Id
     * @param x_ms_as_user The name of user whom you want to make request as. You must be an HPC Pack administrator or HPC Pack Job administrator to make it work.
     * @param properties Properties of task to set.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setTaskProperties(jobId: number, taskId: number, x_ms_as_user?: string, properties?: Array<RestProperty>, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public setTaskProperties(jobId: number, taskId: number, x_ms_as_user?: string, properties?: Array<RestProperty>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public setTaskProperties(jobId: number, taskId: number, x_ms_as_user?: string, properties?: Array<RestProperty>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public setTaskProperties(jobId: number, taskId: number, x_ms_as_user?: string, properties?: Array<RestProperty>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (jobId === null || jobId === undefined) {
            throw new Error('Required parameter jobId was null or undefined when calling setTaskProperties.');
        }

        if (taskId === null || taskId === undefined) {
            throw new Error('Required parameter taskId was null or undefined when calling setTaskProperties.');
        }



        let headers = this.defaultHeaders;
        if (x_ms_as_user !== undefined && x_ms_as_user !== null) {
            headers = headers.set('x-ms-as-user', String(x_ms_as_user));
        }

        // authentication (basic) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<any>(`${this.basePath}/jobs/${encodeURIComponent(String(jobId))}/tasks/${encodeURIComponent(String(taskId))}`,
            properties,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Submit Job
     * Submit a job to the HPC Job Scheduler Service so that the HPC Job Scheduler Service can add the job to the queue of jobs to run. If the credentials for the account under which the job should run are not cached on the server, you can set them in the UserName and Password properties. A job that is submitted by this operation is not validated. After the job is submitted, you can get information about the job by using the Get Job operation.
     * @param jobId Job Id
     * @param x_ms_as_user The name of user whom you want to make request as. You must be an HPC Pack administrator or HPC Pack Job administrator to make it work.
     * @param properties Properties of job to submit
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public submitJob(jobId: number, x_ms_as_user?: string, properties?: Array<RestProperty>, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public submitJob(jobId: number, x_ms_as_user?: string, properties?: Array<RestProperty>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public submitJob(jobId: number, x_ms_as_user?: string, properties?: Array<RestProperty>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public submitJob(jobId: number, x_ms_as_user?: string, properties?: Array<RestProperty>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (jobId === null || jobId === undefined) {
            throw new Error('Required parameter jobId was null or undefined when calling submitJob.');
        }



        let headers = this.defaultHeaders;
        if (x_ms_as_user !== undefined && x_ms_as_user !== null) {
            headers = headers.set('x-ms-as-user', String(x_ms_as_user));
        }

        // authentication (basic) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/jobs/${encodeURIComponent(String(jobId))}/submit`,
            properties,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
